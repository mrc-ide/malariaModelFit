---
title: "check_equilibrium"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This package contains two sets of code for returning the equilibrium solution to the Griffin et al. 2014 transmission model. The first was written in R by Jamie Griffin, and the second was written in Rcpp by Xiaoyu Li, before being adapted into package format by Bob Verity. Here we will compare both sets of code to establish 1) that both sets of code produce the same results, 2) which code set is faster and by how much.

## Install package

Start by installing and loading the package. Run the following lines, uncommenting the first line and replacing `my_token` with your personal Github personal access token (this is required as the package is currently private).

```{r}
# install_github("mrc-ide/malariaModelFit", auth_token=my_token)
library(malariaModelFit)
```

## Compare solutions

Required inputs when determining the equilibrium solution include; entomological innoculation rate (EIR), treatment coverage (ft), a vector of parameters (p), the age distribution of the population (age), and Gaussian quadrature parameters capturing biting heterogeneity (h). We will fix age and biting heterogeneity and draw `n` random values for the other inputs.

```{r}
n <- 1e1 # number of random inputs to explore

age <- default_age()
h <- statmod::gauss.quad.prob(9, dist="normal")
EIR <- runif(n,1,100)
ft <- runif(n)
p <- random_parameters(n)

plot_nice1(rnorm(10))
```

Now calculate equilibrium solution under both methods, and check that results are equal using `all.equal`, which checks for "near equality".

```{r}
is_equal <- rep(NA,n)
for (i in 1:n) {
  eq1 <- human_equilibrium(EIR=EIR[i], ft=ft[i], p=p[[i]], age=age, h=h)
  eq2 <- human_equilibrium_fast(EIR=EIR[i], ft=ft[i], p=p[[i]], age=age, h$nodes, h$weights)
  is_equal[i] <- all.equal(eq1,eq2)
}

# check that results match
if (all(is_equal)) {
  cat("Good news - solutions match exactly!\n")
} else {
  warning("Solutions do not match")
}
```

Hopefully you got good news when running the above, otherwise check your code for bugs!


## Compare speed

We will compare speed with the `microbenchmark` package. Here we compare evaluation time for each of the `n` parameter sets generated above, repeating the evaluation `repeats` times in each case. Overall results are stored in the list `res`, and the median over repeats is stored in the matrix `res_median`.

```{r}
library(microbenchmark)

repeats <- 1e0  # number of times to repeat evaluation for each parameter set

# loop over parameter sets
res <- NULL
res_median <- matrix(NA,n,2)
for (i in 1:n) {
  
  # benchmark functions
  res_i <- microbenchmark(
    human_equilibrium(EIR=EIR[i], ft=ft[i], p=p[[i]], age=age, h=h),
    human_equilibrium_fast(EIR=EIR[i], ft=ft[i], p=p[[i]], age=age, h$nodes, h$weights),
    times=repeats
  )
  
  # store results
  res$expr <- c(res$expr, res_i$expr)
  res$time <- c(res$time, res_i$time)
  res_median[i,] <- summary(res_i)$median
}
```

We can now produce a box-plot over all results:

```{r}
functionNames <- c("human_equilibrium","human_equilibrium_fast")
boxplot(split(res$time, f=res$expr), names=functionNames, ylab="evaluation time")
```

or we can dig deeper into timings by plotting evaluation time against EIR or treatment rate:

```{r}
# plot evalutation time against EIR
par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE)
plot(0, type='n', xlim=range(EIR), ylim=c(0,max(res_median)), xlab="EIR", ylab='evaluation time', main='evaluation time against EIR')
points(EIR, res_median[,1], col=2, pch=20)
points(EIR, res_median[,2], col=3, pch=20)
legend(x='topright', inset=c(-0.5,0), legend=functionNames, col=c(2,3), pch=20)

# plot evalutation time against treatment rate
plot(0, type='n', xlim=c(0,1), ylim=c(0,max(res_median)), xlab="treatment rate", ylab='evaluation time', main='evaluation time against treatment rate')
points(ft, res_median[,1], col=2, pch=20)
points(ft, res_median[,2], col=3, pch=20)
legend(x='topright', legend=functionNames, col=c(2,3), pch=20)
```